// Generated by CoffeeScript 2.0.0-beta6
void function () {
  var async, coffee, emport, expandMapShorthand, fs, getContentsInOrder, glob, parseLine, parseSourceForImportsAndExports, path, resolveDeps;
  path = require('path');
  fs = require('fs');
  glob = require('glob');
  async = require('async');
  coffee = require('coffee-script-redux');
  module.exports = emport = function (targetFilename, options, callback) {
    var basePaths, emportMap;
    basePaths = options.paths || [path.dirname(targetFilename)];
    emportMap = {};
    return async.forEachSeries(basePaths, function (basePath, cb) {
      return async.waterfall([
        function (cb) {
          var basePathGlob, cache$;
          cache$ = basePath.split(' ');
          basePath = cache$[0];
          basePathGlob = cache$[1];
          if (null != basePathGlob)
            basePathGlob;
          else
            basePathGlob = '**/*.@(js|coffee)';
          return glob(basePath + '/' + basePathGlob, cb);
        },
        function (filenames, cb) {
          return async.forEach(filenames, function (filename, eachCb) {
            return fs.readFile(filename, 'utf8', function (err, contents) {
              var importsAndExports, relPath;
              if (!(null != contents))
                return eachCb();
              relPath = path.relative(basePath, filename);
              importsAndExports = parseSourceForImportsAndExports(contents);
              emportMap[relPath] = importsAndExports;
              emportMap[relPath].contents = contents;
              return eachCb();
            });
          }, cb);
        }
      ], cb);
    }, function (err) {
      var contentsInOrder, dependencies, e, exports, exportVar, filename, filenamesInOrder, importsAndExports;
      if (null != err)
        return callback(err);
      if (null != options.map) {
        expandMapShorthand(options.map);
        for (filename in options.map) {
          importsAndExports = options.map[filename];
          if (!(null != emportMap[filename]))
            return callback('' + filename + ' not found');
          emportMap[filename].imports = importsAndExports.imports;
          emportMap[filename].exports = importsAndExports.exports;
        }
      }
      exports = {};
      for (filename in emportMap) {
        importsAndExports = emportMap[filename];
        for (var i$ = 0, length$ = importsAndExports.exports.length; i$ < length$; ++i$) {
          exportVar = importsAndExports.exports[i$];
          exports[exportVar] = filename;
        }
      }
      dependencies = {};
      for (filename in emportMap) {
        importsAndExports = emportMap[filename];
        dependencies[filename] = function (accum$) {
          var importVar;
          for (var i$1 = 0, length$1 = importsAndExports.imports.length; i$1 < length$1; ++i$1) {
            importVar = importsAndExports.imports[i$1];
            accum$.push(null != exports[importVar] ? exports[importVar] : function () {
              throw new Error('no file exports ' + importVar + ', called from ' + filename);
            }());
          }
          return accum$;
        }.call(this, []);
      }
      filenamesInOrder = resolveDeps(targetFilename, dependencies);
      filenamesInOrder.push(targetFilename);
      try {
        contentsInOrder = getContentsInOrder(filenamesInOrder, emportMap);
      } catch (e$) {
        e = e$;
        return callback(e);
      }
      return callback(null, contentsInOrder.join('\n'));
    });
  };
  resolveDeps = function (filename, depsMap, resolvedDeps) {
    var depFilename, depFilenames;
    if (null == resolvedDeps)
      resolvedDeps = [];
    if (!(depFilenames = depsMap[filename]))
      return [];
    for (var i$ = 0, length$ = depFilenames.length; i$ < length$; ++i$) {
      depFilename = depFilenames[i$];
      if (!!in$(depFilename, resolvedDeps))
        continue;
      resolveDeps(depFilename, depsMap, resolvedDeps);
      resolvedDeps.push(depFilename);
    }
    return resolvedDeps;
  };
  parseSourceForImportsAndExports = function (source) {
    var line, out;
    out = {
      imports: [],
      exports: []
    };
    for (var cache$ = source.split('\n'), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
      line = cache$[i$];
      parseLine(line, out);
    }
    return out;
  };
  parseLine = function (line, out) {
    var match;
    match = line.match(/^(?:#|\/\/)@((?:im|ex)port)\s+(\S+)/);
    if (null != match)
      return out[match[1] + 's'].push(match[2]);
  };
  expandMapShorthand = function (inputMap) {
    return function (accum$) {
      var filename, h;
      for (filename in inputMap) {
        h = inputMap[filename];
        accum$.push(function (accum$1) {
          var k;
          for (var cache$ = [
                'imports',
                'exports'
              ], i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
            k = cache$[i$];
            if (null != h[k])
              h[k];
            else
              h[k] = [];
            accum$1.push(typeof h[k] === 'string' ? h[k] = [h[k]] : void 0);
          }
          return accum$1;
        }.call(this, []));
      }
      return accum$;
    }.call(this, []);
  };
  getContentsInOrder = function (filenamesInOrder, emportMap) {
    return function (accum$) {
      var contents, filename;
      for (var i$ = 0, length$ = filenamesInOrder.length; i$ < length$; ++i$) {
        filename = filenamesInOrder[i$];
        contents = emportMap[filename].contents;
        accum$.push(filename.match(/\.coffee$/) ? function () {
          var e;
          try {
            return coffee.cs2js(contents, { filename: filename });
          } catch (e$) {
            e = e$;
            e.message += '\n when processing ' + filename;
            throw e;
          }
        }.call(this) : contents);
      }
      return accum$;
    }.call(this, []);
  };
  function in$(member, list) {
    for (var i = 0, length = list.length; i < length; ++i)
      if (i in list && list[i] === member)
        return true;
    return false;
  }
}.call(this);
